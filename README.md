# beelog
*beelog* package implements a series of recovery mechanisms for SMR applications, relying on efficient data structures and log compaction algorithms to safely discard entries from the command log. *beelog* protocol is orthogonal to any checkpoint implementation, providing a simple API for log configuration and recovery.

## Recovery Protocol
Once crashed, recovery initializes right after the system restarts. The first step is to retrieve the latest application’s checkpoint, locally presented or requested to other replicas atomically. Assuming incremental check-pointing procedures, only the latest state is required for a fresh state recovery. After installing the snapshot, the replica is informed of the latest consensus index λ reflected on the installed state, this determines the lower-bound index p = λ+1 of the remaining interval of commands to be recovered. If no checkpoint is received, p = 0 is set. On the next step the replica re-enters consensus, where it perceives the newest command of index *e* being proposed. Assuming monotonically-incremented indexes, it is safe to assume n = *e* − 1 as the upper-bound of the remaining interval. Finally, [p, n] represents the gap between snapshot and application’s current state that must be processed in order for the replica to be recovered. Traditionally the interval [p, n] is recovered by processing a command log, stored in the replicas stable storage where it is assumed to fault-resilient. The indexes p and n are directly mapped into arguments recognized by the recover procedure on the logger’s API. After processing the retrieved command interval, and the buffered new commands stored after reentering consensus, the system is safe to process newly proposed indexes again. Considering the traditional state machine approach, no commands are executed until the system is fully recovered.

### Considerations
The definition of an upper-bound index n implies not only that the informed log maps the application’s state until the n*th* command, but also that the informed log is compacted until the n*th* command. During recovery, after requesting a [i, n] interval, the replica stores newly received commands from consensus into a buffer to be later replayed after the process of the log. During log transferring and installation, the buffer can growth wildly, specially in high throughput applications. Considering that a replicas stores into its buffer until the θ*th* command, and θ ≫ n, its considered inefficient to reprocess the interval (n, θ] if the θ index was already present in the log structure, but not requested. This can naturally happen due to message delay in a distributed system, but it can be treated after a few adjustments on the recovery protocol.

### Unbounded Recovery
Implemented on **Interval** configuration, the unbounded variant tackles the described problem by always providing the highest index interpreted during recovery, not relying on a n parameter. By storing a local variable δ, representing the latest consensus index processed; δ is not only incremented by the latest node (i.e. write operation) inserted, but also by read operations safely discarded. In this case, the advantages of an unbound recovery procedure would be perceived during the process of the commands in the [i, δ] ∩ (n, θ] set intersection.
